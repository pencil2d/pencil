#include "theming.h"

#include <QDir>
#include <QPalette>
#include <QSettings>
#include <QStandardPaths>
#include <QStyleFactory>
#include <QStyle>

#include "pencilerror.h"

/**
 * Get a list of all valid keys that can be passed to Theming::getStyle().
 *
 * The exact list will vary depending on the platform, loaded Qt plugins,
 * and the Qt runtime configuration.
 *
 * @return A list of string keys.
 * @see getStyle()
 */
QStringList Theming::availableStyles()
{
    return QStyleFactory::keys();
}

/**
 * Get a list of all valid keys that can be passed to Theming::getPalette().
 *
 * This list is generated by finding all built-in palettes, and all .conf
 * files in the user's palette directory. This may include invalid palettes.
 * Filter using ThemeColorPalette::isValid if only valid palettes are required.
 *
 * @return A list of loaded palettes.
 * @see getPalette()
 */
QList<ThemeColorPalette> Theming::availablePalettes()
{
    QList<ThemeColorPalette> palettes;

    // Built-in palettes
    QDir builtinDir(":/theme_palettes");
    for (const QString& palettePath : builtinDir.entryList({"*.conf"}, QDir::Files))
    {
        palettes.append(builtinDir.filePath(palettePath));
    }

    // User palettes
    QDir userDir = userPaletteDir();
    for (const QString& palettePath : userDir.entryList({"*.conf"}, QDir::Files))
    {
        palettes.append(userDir.filePath(palettePath));
    }

    return palettes;
}

/**
 * Fetch a style with a given key.
 *
 * @param key A case-insensitive style identifier. Current defined by the Qt plugin providing the style.
 * @return A QStyle instance corresponding to the given key or a null pointer if there is none.
 * @see availableStyles()
 */
QStyle* Theming::getStyle(const QString& key)
{
    QStyle* style = QStyleFactory::create(key);

    return style;
}

/**
 * Fetch a palette with a given key.
 *
 * @param key A palette identifier.
 * @return A loaded palette corresponding to the given key. If no palette with the key exists,
 *         or the conf file for the palette is invalid, an invalid palette will be returned.
 * @see availablePalettes()
 */
ThemeColorPalette Theming::getPalette(const QString& key)
{
    if (key.startsWith("builtin-"))
    {
        return ThemeColorPalette(QString(":/theme_palettes/%1.conf").arg(key.mid(8)));
    }
    else if (key.startsWith("user-"))
    {
        return ThemeColorPalette(userPaletteDir().filePath(QString("%1.conf").arg(key.mid(5))));
    }
    return ThemeColorPalette();
}

/**
 * Saves a palette to the user's palette directory.
 *
 * @param filePath The path to a .conf palette file to load.
 * @return A Status indicating if the palette was added successfully.
 */
Status Theming::addPalette(const QString& filePath)
{
    // Perform some basic checks to provide more detailed errors
    if (!filePath.endsWith(".conf")) return Status::INVALID_ARGUMENT;
    QFileInfo fileInfo(filePath);
    if (fileInfo.baseName().isEmpty()) return Status::INVALID_ARGUMENT;
    if (!fileInfo.isFile()) return Status::FILE_NOT_FOUND;
    if (!fileInfo.isReadable()) return Status::ERROR_FILE_CANNOT_OPEN;

    // Attempt to construct the palette and verify that it is valid
    ThemeColorPalette palette(filePath);
    if (!palette.isValid()) return Status::FAIL;

    // Copy to the user's palette directory
    QFile inFile(filePath);
    if (inFile.copy(userPaletteDir().filePath(fileInfo.fileName())))
    {
        return Status::OK;
    }
    return Status::FAIL;
}

/**
 * Removes a palette from the user's palette directory.
 *
 * The .conf palette file will be deleted by this function and cannot be undone.
 *
 * @param key The palette id of the palette to remove.
 * @return A Status indicated if the palette was removed successfully.
 */
Status Theming::removePalette(const QString& key)
{
    if (!key.startsWith("user-")) return Status::FAIL;

    QFile paletteFile(userPaletteDir().filePath(QString("%1.conf").arg(key.mid(5))));
    if (paletteFile.remove())
    {
        return Status::OK;
    }
    return Status::FAIL;
}

/**
 * Convenience function to get the user palette dir.
 *
 * @return The path to the directory to write user added palettes to.
 */
const QDir Theming::userPaletteDir()
{
    QDir dir(QStandardPaths::writableLocation(QStandardPaths::AppDataLocation));
    dir.cd("theme_palettes");

    return dir;
}

ThemeColorPalette::ThemeColorPalette(const QString& filePath)
{
    loadFromFile(filePath);
}

/**
 * Create a QPalette instance from a .conf palette file.
 *
 * The file format must be in the INI format. It should have a ColorScheme group with
 * active_colors, disabled_colors, and inactive_colors keys. Each should have at least 20 string list values
 * corresponding to colors (typically in a hexadecimal RGBA format, ex #ff424245).
 *
 * @param filename The path to the .conf file to load.
 * @return A QPalette instance with the color set from the .conf or nullptr if the file cannot be loaded or is not valid.
 */
bool ThemeColorPalette::loadFromFile(const QString& filePath)
{
    m_valid = tryLoad(filePath);
    return m_valid;
}

QString ThemeColorPalette::id() const
{
    QFileInfo fileInfo(m_filePath);
    return fileInfo.baseName().prepend(isBuiltIn() ? "builtin-" : "user-");
}

/**
 * Private implementation of loadFromFile.
 *
 * @see ThemeColorPalette::loadFromFile
 */
bool ThemeColorPalette::tryLoad(const QString& filePath)
{
    m_valid = false;
    m_filePath = filePath;

    if (!filePath.endsWith(".conf")) return false;
    QFileInfo fileInfo(filePath);
    if (fileInfo.baseName().isEmpty()) return false;
    //if (!fileInfo.isFile()) return false;
    if (!fileInfo.isReadable()) return false;

    QSettings conf(filePath, QSettings::IniFormat);

    conf.beginGroup("Metadata");
    m_displayName = conf.value("DisplayName", fileInfo.baseName()).toString();
    m_isDark = conf.value("IsDark", false).toBool();
    conf.endGroup();

    conf.beginGroup("ColorScheme");
    QList<std::pair<QPalette::ColorGroup, QString>> colorGroups = {
        { QPalette::Active, "active_colors" },
        { QPalette::Disabled, "disabled_colors" },
        { QPalette::Inactive, "inactive_colors" }
    };
    for (const auto& colorGroup : colorGroups)
    {
        QStringList colors = conf.value(colorGroup.second).toStringList();
        // 20 is QPalette::NColorRoles prior to Qt 5.12, and is the minimum number of colors required for this format.
        if (colors.count() < 20) return false;

        for (int i = 0; i < qMin(colors.count(), static_cast<int>(QPalette::NColorRoles)); i++)
        {
            m_palette.setColor(colorGroup.first, QPalette::ColorRole(i), colors[i]);
        }
    }
    conf.endGroup();

    return true;
}
