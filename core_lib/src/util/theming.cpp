#include "theming.h"

#include <QDir>
#include <QPalette>
#include <QSettings>
#include <QStandardPaths>
#include <QStyleFactory>
#include <QStyle>

#include "pencilerror.h"

/**
 * Get a list of all valid keys that can be passed to Theming::getStyle().
 *
 * The exact list will vary depending on the platform, loaded Qt plugins,
 * and the Qt runtime configuration.
 *
 * @return A list of string keys.
 * @see getStyle()
 */
QStringList Theming::availableStyles()
{
    return QStyleFactory::keys();
}

/**
 * Get a list of all valid keys that can be passed to Theming::getPalette().
 *
 * This list is generated by finding all built-in palettes, and all .conf
 * files in the user's palette directory. This may include invalid palettes.
 * Filter using ThemeColorPalette::isValid if only valid palettes are required.
 *
 * @return A list of loaded palettes.
 * @see getPalette()
 */
QList<ThemeColorPalette> Theming::availablePalettes()
{
    QList<ThemeColorPalette> palettes;

    // Built-in palettes
    QDir builtinDir(":/theme_palettes");
    for (const QString& palettePath : builtinDir.entryList({"*.conf"}, QDir::Files))
    {
        palettes.append(builtinDir.filePath(palettePath));
    }

    // User palettes
    QDir userDir = userPaletteDir();
    for (const QString& palettePath : userDir.entryList({"*.conf"}, QDir::Files))
    {
        palettes.append(userDir.filePath(palettePath));
    }

    return palettes;
}

/**
 * Fetch a style with a given key.
 *
 * @param key A case-insensitive style identifier. Current defined by the Qt plugin providing the style.
 * @return A QStyle instance corresponding to the given key or a null pointer if there is none.
 * @see availableStyles()
 */
QStyle* Theming::getStyle(const QString& key)
{
    QStyle* style = QStyleFactory::create(key);

    return style;
}

/**
 * Fetch a palette with a given key.
 *
 * @param key A palette identifier.
 * @return A loaded palette corresponding to the given key. If no palette with the key exists,
 *         or the conf file for the palette is invalid, an invalid palette will be returned.
 * @see availablePalettes()
 */
ThemeColorPalette Theming::getPalette(const QString& key)
{
    if (key.startsWith("builtin-"))
    {
        return ThemeColorPalette(QString(":/theme_palettes/%1.conf").arg(key.mid(8)));
    }
    else if (key.startsWith("user-"))
    {
        return ThemeColorPalette(userPaletteDir().filePath(QString("%1.conf").arg(key.mid(5))));
    }
    ThemeColorPalette invalidPalette;
    invalidPalette.setInvalidWithId(key);
    return invalidPalette;
}

/**
 * Saves a palette to the user's palette directory.
 *
 * @param filePath The path to a .conf palette file to load.
 * @return A Status indicating if the palette was added successfully, and the new
 *         palette if successful.
 */
std::pair<Status, ThemeColorPalette> Theming::addPalette(const QString& filePath)
{
    ThemeColorPalette palette;
    DebugDetails dd;
    dd << QString("Raw file path: %1").arg(filePath);
    QString errorTitle = QCoreApplication::translate("Theming", "Unable to load color palette");

    // Perform some basic checks to provide more detailed errors
    if (!filePath.endsWith(".conf")) return { Status(Status::INVALID_ARGUMENT, dd, errorTitle, QCoreApplication::translate("Theming", "Color palette file is the wrong format. Only .ini files are accepted.")), palette };
    QFileInfo fileInfo(filePath);
    if (fileInfo.baseName().isEmpty()) return { Status(Status::INVALID_ARGUMENT, dd, errorTitle, QCoreApplication::translate("Theming", "The filename cannot be empty.")), palette };
    if (!fileInfo.isFile()) return { Status(Status::FILE_NOT_FOUND, dd, errorTitle, QCoreApplication::translate("Theming", "File not found or cannot be read.")), palette };
    if (!fileInfo.isReadable()) return { Status(Status::ERROR_FILE_CANNOT_OPEN, dd, errorTitle, QCoreApplication::translate("Theming", "File not found or cannot be read.")), palette };

    // Attempt to construct the palette and verify that it is valid
    palette.loadFromFile(filePath);
    if (!palette.isValid()) return { Status(Status::FAIL, dd, errorTitle, QCoreApplication::translate("Theming", "Cannot load color palette, the file is not in the correct format or contains errors.")), palette };

    // Copy to the user's palette directory
    QFile inFile(filePath);
    QDir destDir = userPaletteDir();
    QString destPath = destDir.filePath(fileInfo.fileName());
    QFileInfo destFileInfo(destPath);
    int offset = 0;
    while (destFileInfo.exists())
    {
        destFileInfo.setFile(destDir.filePath(QString("%1-%2.conf").arg(fileInfo.baseName()).arg(++offset)));
        destPath = destFileInfo.absoluteFilePath();
    }
    dd << QString("Palette save path: %1").arg(destPath);
    if (inFile.copy(destPath))
    {
        return { Status::OK, ThemeColorPalette(destPath) };
    }
    return { Status(Status::FAIL, dd, errorTitle, QCoreApplication::translate("Theming", "An internal error occurred and the palette could not be saved.")), palette };
}

/**
 * Removes a palette from the user's palette directory.
 *
 * The .conf palette file will be deleted by this function and cannot be undone.
 *
 * @param key The palette id of the palette to remove.
 * @return A Status indicated if the palette was removed successfully.
 */
Status Theming::removePalette(const QString& key)
{
    DebugDetails dd;
    dd << QString("Palette key: %1").arg(key);
    QString errorTitle = QCoreApplication::translate("Theming", "Unable to delete color palette");

    if (!key.startsWith("user-")) return Status(Status::FAIL, dd, errorTitle, QCoreApplication::translate("Theming", "This palette is built-in and cannot be deleted."));

    QString destPath = userPaletteDir().filePath(QString("%1.conf").arg(key.mid(5)));
    dd << QString("Palette path: %1").arg(destPath);
    QFile paletteFile(destPath);
    if (!paletteFile.exists() || paletteFile.remove())
    {
        return Status::OK;
    }
    return Status(Status::FAIL, dd, errorTitle, QCoreApplication::translate("Theming", "Unable to delete palette file."));
}

/**
 * Convenience function to get the user palette dir.
 *
 * @return The path to the directory to write user added palettes to.
 */
const QDir Theming::userPaletteDir()
{
    QDir dir(QStandardPaths::writableLocation(QStandardPaths::AppDataLocation));
    dir.cd("theme_palettes");

    return dir;
}

ThemeColorPalette::ThemeColorPalette(const QString& filePath)
{
    loadFromFile(filePath);
}

/**
 * Create a QPalette instance from a .conf palette file.
 *
 * The file format must be in the INI format. It should have a ColorScheme group with
 * active_colors, disabled_colors, and inactive_colors keys. Each should have at least 20 string list values
 * corresponding to colors (typically in a hexadecimal RGBA format, ex #ff424245).
 *
 * @param filename The path to the .conf file to load.
 * @return A QPalette instance with the color set from the .conf or nullptr if the file cannot be loaded or is not valid.
 */
bool ThemeColorPalette::loadFromFile(const QString& filePath)
{
    m_valid = tryLoad(filePath);
    return m_valid;
}

/**
 * Sets the id but marks it as invalid.
 *
 * This function can be used to create a palette with a desired id
 * without a valid file path.
 *
 * @param id
 */
void ThemeColorPalette::setInvalidWithId(const QString& id)
{
    m_valid = false;
    m_mode = Mode::Unknown;
    if (id.contains('-'))
    {
        m_filePath = QString("%1.conf").arg(id);
        m_displayName = id.mid(id.indexOf('-'));
    }
    else
    {
        m_filePath = QString("user-%1.conf").arg(id);
        m_displayName = id;
    }
}

QString ThemeColorPalette::id() const
{
    QFileInfo fileInfo(m_filePath);
    return fileInfo.baseName().prepend(isBuiltIn() ? "builtin-" : "user-");
}

bool ThemeColorPalette::isDark() const
{
    if (!m_valid) return false;

    if (m_mode == Mode::Unknown)
    {
        // Guess the mode based on the lightness of the background color
        QColor backgroundColor = m_palette.color(QPalette::Normal, QPalette::Window);
        return backgroundColor.lightnessF() < 0.5;
    }
    return m_mode == Mode::Dark;
}

/**
 * Private implementation of loadFromFile.
 *
 * @see ThemeColorPalette::loadFromFile
 */
bool ThemeColorPalette::tryLoad(const QString& filePath)
{
    m_valid = false;
    m_filePath = filePath;

    QFileInfo fileInfo(filePath);
    m_displayName = fileInfo.baseName();
    if (!filePath.endsWith(".conf")) return false;
    if (fileInfo.baseName().isEmpty()) return false;
    //if (!fileInfo.isFile()) return false;
    if (!fileInfo.isReadable()) return false;

    QSettings conf(filePath, QSettings::IniFormat);

    conf.beginGroup("Metadata");
    m_displayName = conf.value("DisplayName", m_displayName).toString();

    QString modeStr = conf.value("LightOrDark").toString().toLower();
    if (modeStr == "light") m_mode = Mode::Light;
    else if (modeStr == "dark") m_mode = Mode::Dark;
    else m_mode = Mode::Unknown;

    conf.endGroup();

    conf.beginGroup("ColorScheme");
    QList<std::pair<QPalette::ColorGroup, QString>> colorGroups = {
        { QPalette::Active, "active_colors" },
        { QPalette::Disabled, "disabled_colors" },
        { QPalette::Inactive, "inactive_colors" }
    };
    m_palette = QPalette();
    for (const auto& colorGroup : colorGroups)
    {
        QStringList colors = conf.value(colorGroup.second).toStringList();
        // 20 is QPalette::NColorRoles prior to Qt 5.12, and is the minimum number of colors required for this format.
        if (colors.count() < 20) return false;

        for (int i = 0; i < qMin(colors.count(), static_cast<int>(QPalette::NColorRoles)); i++)
        {
            m_palette.setColor(colorGroup.first, QPalette::ColorRole(i), colors[i]);
        }
    }
    conf.endGroup();

    return true;
}
